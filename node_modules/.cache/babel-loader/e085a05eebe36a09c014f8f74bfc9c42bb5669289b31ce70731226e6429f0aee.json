{"ast":null,"code":"/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar _t = function t(r, e) {\n  return (_t = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (t, r) {\n    t.__proto__ = r;\n  } || function (t, r) {\n    for (var e in r) r.hasOwnProperty(e) && (t[e] = r[e]);\n  })(r, e);\n};\nfunction r(r, e) {\n  function i() {\n    this.constructor = r;\n  }\n  _t(r, e), r.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i());\n}\nfunction e(t) {\n  var r = \"\";\n  Array.isArray(t) || (t = [t]);\n  for (var e = 0; e < t.length; e++) {\n    var i = t[e];\n    if (i.type === f.CLOSE_PATH) r += \"z\";else if (i.type === f.HORIZ_LINE_TO) r += (i.relative ? \"h\" : \"H\") + i.x;else if (i.type === f.VERT_LINE_TO) r += (i.relative ? \"v\" : \"V\") + i.y;else if (i.type === f.MOVE_TO) r += (i.relative ? \"m\" : \"M\") + i.x + \" \" + i.y;else if (i.type === f.LINE_TO) r += (i.relative ? \"l\" : \"L\") + i.x + \" \" + i.y;else if (i.type === f.CURVE_TO) r += (i.relative ? \"c\" : \"C\") + i.x1 + \" \" + i.y1 + \" \" + i.x2 + \" \" + i.y2 + \" \" + i.x + \" \" + i.y;else if (i.type === f.SMOOTH_CURVE_TO) r += (i.relative ? \"s\" : \"S\") + i.x2 + \" \" + i.y2 + \" \" + i.x + \" \" + i.y;else if (i.type === f.QUAD_TO) r += (i.relative ? \"q\" : \"Q\") + i.x1 + \" \" + i.y1 + \" \" + i.x + \" \" + i.y;else if (i.type === f.SMOOTH_QUAD_TO) r += (i.relative ? \"t\" : \"T\") + i.x + \" \" + i.y;else {\n      if (i.type !== f.ARC) throw new Error('Unexpected command type \"' + i.type + '\" at index ' + e + \".\");\n      r += (i.relative ? \"a\" : \"A\") + i.rX + \" \" + i.rY + \" \" + i.xRot + \" \" + +i.lArcFlag + \" \" + +i.sweepFlag + \" \" + i.x + \" \" + i.y;\n    }\n  }\n  return r;\n}\nfunction i(t, r) {\n  var e = t[0],\n    i = t[1];\n  return [e * Math.cos(r) - i * Math.sin(r), e * Math.sin(r) + i * Math.cos(r)];\n}\nfunction a() {\n  for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];\n  for (var e = 0; e < t.length; e++) if (\"number\" != typeof t[e]) throw new Error(\"assertNumbers arguments[\" + e + \"] is not a number. \" + typeof t[e] + \" == typeof \" + t[e]);\n  return !0;\n}\nvar n = Math.PI;\nfunction o(t, r, e) {\n  t.lArcFlag = 0 === t.lArcFlag ? 0 : 1, t.sweepFlag = 0 === t.sweepFlag ? 0 : 1;\n  var a = t.rX,\n    o = t.rY,\n    s = t.x,\n    u = t.y;\n  a = Math.abs(t.rX), o = Math.abs(t.rY);\n  var h = i([(r - s) / 2, (e - u) / 2], -t.xRot / 180 * n),\n    c = h[0],\n    y = h[1],\n    p = Math.pow(c, 2) / Math.pow(a, 2) + Math.pow(y, 2) / Math.pow(o, 2);\n  1 < p && (a *= Math.sqrt(p), o *= Math.sqrt(p)), t.rX = a, t.rY = o;\n  var m = Math.pow(a, 2) * Math.pow(y, 2) + Math.pow(o, 2) * Math.pow(c, 2),\n    O = (t.lArcFlag !== t.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a, 2) * Math.pow(o, 2) - m) / m)),\n    T = a * y / o * O,\n    v = -o * c / a * O,\n    l = i([T, v], t.xRot / 180 * n);\n  t.cX = l[0] + (r + s) / 2, t.cY = l[1] + (e + u) / 2, t.phi1 = Math.atan2((y - v) / o, (c - T) / a), t.phi2 = Math.atan2((-y - v) / o, (-c - T) / a), 0 === t.sweepFlag && t.phi2 > t.phi1 && (t.phi2 -= 2 * n), 1 === t.sweepFlag && t.phi2 < t.phi1 && (t.phi2 += 2 * n), t.phi1 *= 180 / n, t.phi2 *= 180 / n;\n}\nfunction s(t, r, e) {\n  a(t, r, e);\n  var i = t * t + r * r - e * e;\n  if (0 > i) return [];\n  if (0 === i) return [[t * e / (t * t + r * r), r * e / (t * t + r * r)]];\n  var n = Math.sqrt(i);\n  return [[(t * e + r * n) / (t * t + r * r), (r * e - t * n) / (t * t + r * r)], [(t * e - r * n) / (t * t + r * r), (r * e + t * n) / (t * t + r * r)]];\n}\nvar u,\n  h = Math.PI / 180;\nfunction c(t, r, e) {\n  return (1 - e) * t + e * r;\n}\nfunction y(t, r, e, i) {\n  return t + Math.cos(i / 180 * n) * r + Math.sin(i / 180 * n) * e;\n}\nfunction p(t, r, e, i) {\n  var a = r - t,\n    n = e - r,\n    o = 3 * a + 3 * (i - e) - 6 * n,\n    s = 6 * (n - a),\n    u = 3 * a;\n  return Math.abs(o) < 1e-6 ? [-u / s] : function (t, r, e) {\n    void 0 === e && (e = 1e-6);\n    var i = t * t / 4 - r;\n    if (i < -e) return [];\n    if (i <= e) return [-t / 2];\n    var a = Math.sqrt(i);\n    return [-t / 2 - a, -t / 2 + a];\n  }(s / o, u / o, 1e-6);\n}\nfunction m(t, r, e, i, a) {\n  var n = 1 - a;\n  return t * (n * n * n) + r * (3 * n * n * a) + e * (3 * n * a * a) + i * (a * a * a);\n}\n!function (t) {\n  function r() {\n    return u(function (t, r, e) {\n      return t.relative && (void 0 !== t.x1 && (t.x1 += r), void 0 !== t.y1 && (t.y1 += e), void 0 !== t.x2 && (t.x2 += r), void 0 !== t.y2 && (t.y2 += e), void 0 !== t.x && (t.x += r), void 0 !== t.y && (t.y += e), t.relative = !1), t;\n    });\n  }\n  function e() {\n    var t = NaN,\n      r = NaN,\n      e = NaN,\n      i = NaN;\n    return u(function (a, n, o) {\n      return a.type & f.SMOOTH_CURVE_TO && (a.type = f.CURVE_TO, t = isNaN(t) ? n : t, r = isNaN(r) ? o : r, a.x1 = a.relative ? n - t : 2 * n - t, a.y1 = a.relative ? o - r : 2 * o - r), a.type & f.CURVE_TO ? (t = a.relative ? n + a.x2 : a.x2, r = a.relative ? o + a.y2 : a.y2) : (t = NaN, r = NaN), a.type & f.SMOOTH_QUAD_TO && (a.type = f.QUAD_TO, e = isNaN(e) ? n : e, i = isNaN(i) ? o : i, a.x1 = a.relative ? n - e : 2 * n - e, a.y1 = a.relative ? o - i : 2 * o - i), a.type & f.QUAD_TO ? (e = a.relative ? n + a.x1 : a.x1, i = a.relative ? o + a.y1 : a.y1) : (e = NaN, i = NaN), a;\n    });\n  }\n  function n() {\n    var t = NaN,\n      r = NaN;\n    return u(function (e, i, a) {\n      if (e.type & f.SMOOTH_QUAD_TO && (e.type = f.QUAD_TO, t = isNaN(t) ? i : t, r = isNaN(r) ? a : r, e.x1 = e.relative ? i - t : 2 * i - t, e.y1 = e.relative ? a - r : 2 * a - r), e.type & f.QUAD_TO) {\n        t = e.relative ? i + e.x1 : e.x1, r = e.relative ? a + e.y1 : e.y1;\n        var n = e.x1,\n          o = e.y1;\n        e.type = f.CURVE_TO, e.x1 = ((e.relative ? 0 : i) + 2 * n) / 3, e.y1 = ((e.relative ? 0 : a) + 2 * o) / 3, e.x2 = (e.x + 2 * n) / 3, e.y2 = (e.y + 2 * o) / 3;\n      } else t = NaN, r = NaN;\n      return e;\n    });\n  }\n  function u(t) {\n    var r = 0,\n      e = 0,\n      i = NaN,\n      a = NaN;\n    return function (n) {\n      if (isNaN(i) && !(n.type & f.MOVE_TO)) throw new Error(\"path must start with moveto\");\n      var o = t(n, r, e, i, a);\n      return n.type & f.CLOSE_PATH && (r = i, e = a), void 0 !== n.x && (r = n.relative ? r + n.x : n.x), void 0 !== n.y && (e = n.relative ? e + n.y : n.y), n.type & f.MOVE_TO && (i = r, a = e), o;\n    };\n  }\n  function O(t, r, e, i, n, o) {\n    return a(t, r, e, i, n, o), u(function (a, s, u, h) {\n      var c = a.x1,\n        y = a.x2,\n        p = a.relative && !isNaN(h),\n        m = void 0 !== a.x ? a.x : p ? 0 : s,\n        O = void 0 !== a.y ? a.y : p ? 0 : u;\n      function T(t) {\n        return t * t;\n      }\n      a.type & f.HORIZ_LINE_TO && 0 !== r && (a.type = f.LINE_TO, a.y = a.relative ? 0 : u), a.type & f.VERT_LINE_TO && 0 !== e && (a.type = f.LINE_TO, a.x = a.relative ? 0 : s), void 0 !== a.x && (a.x = a.x * t + O * e + (p ? 0 : n)), void 0 !== a.y && (a.y = m * r + a.y * i + (p ? 0 : o)), void 0 !== a.x1 && (a.x1 = a.x1 * t + a.y1 * e + (p ? 0 : n)), void 0 !== a.y1 && (a.y1 = c * r + a.y1 * i + (p ? 0 : o)), void 0 !== a.x2 && (a.x2 = a.x2 * t + a.y2 * e + (p ? 0 : n)), void 0 !== a.y2 && (a.y2 = y * r + a.y2 * i + (p ? 0 : o));\n      var v = t * i - r * e;\n      if (void 0 !== a.xRot && (1 !== t || 0 !== r || 0 !== e || 1 !== i)) if (0 === v) delete a.rX, delete a.rY, delete a.xRot, delete a.lArcFlag, delete a.sweepFlag, a.type = f.LINE_TO;else {\n        var l = a.xRot * Math.PI / 180,\n          _ = Math.sin(l),\n          N = Math.cos(l),\n          x = 1 / T(a.rX),\n          d = 1 / T(a.rY),\n          A = T(N) * x + T(_) * d,\n          E = 2 * _ * N * (x - d),\n          C = T(_) * x + T(N) * d,\n          M = A * i * i - E * r * i + C * r * r,\n          R = E * (t * i + r * e) - 2 * (A * e * i + C * t * r),\n          g = A * e * e - E * t * e + C * t * t,\n          I = (Math.atan2(R, M - g) + Math.PI) % Math.PI / 2,\n          S = Math.sin(I),\n          L = Math.cos(I);\n        a.rX = Math.abs(v) / Math.sqrt(M * T(L) + R * S * L + g * T(S)), a.rY = Math.abs(v) / Math.sqrt(M * T(S) - R * S * L + g * T(L)), a.xRot = 180 * I / Math.PI;\n      }\n      return void 0 !== a.sweepFlag && 0 > v && (a.sweepFlag = +!a.sweepFlag), a;\n    });\n  }\n  function T() {\n    return function (t) {\n      var r = {};\n      for (var e in t) r[e] = t[e];\n      return r;\n    };\n  }\n  t.ROUND = function (t) {\n    function r(r) {\n      return Math.round(r * t) / t;\n    }\n    return void 0 === t && (t = 1e13), a(t), function (t) {\n      return void 0 !== t.x1 && (t.x1 = r(t.x1)), void 0 !== t.y1 && (t.y1 = r(t.y1)), void 0 !== t.x2 && (t.x2 = r(t.x2)), void 0 !== t.y2 && (t.y2 = r(t.y2)), void 0 !== t.x && (t.x = r(t.x)), void 0 !== t.y && (t.y = r(t.y)), void 0 !== t.rX && (t.rX = r(t.rX)), void 0 !== t.rY && (t.rY = r(t.rY)), t;\n    };\n  }, t.TO_ABS = r, t.TO_REL = function () {\n    return u(function (t, r, e) {\n      return t.relative || (void 0 !== t.x1 && (t.x1 -= r), void 0 !== t.y1 && (t.y1 -= e), void 0 !== t.x2 && (t.x2 -= r), void 0 !== t.y2 && (t.y2 -= e), void 0 !== t.x && (t.x -= r), void 0 !== t.y && (t.y -= e), t.relative = !0), t;\n    });\n  }, t.NORMALIZE_HVZ = function (t, r, e) {\n    return void 0 === t && (t = !0), void 0 === r && (r = !0), void 0 === e && (e = !0), u(function (i, a, n, o, s) {\n      if (isNaN(o) && !(i.type & f.MOVE_TO)) throw new Error(\"path must start with moveto\");\n      return r && i.type & f.HORIZ_LINE_TO && (i.type = f.LINE_TO, i.y = i.relative ? 0 : n), e && i.type & f.VERT_LINE_TO && (i.type = f.LINE_TO, i.x = i.relative ? 0 : a), t && i.type & f.CLOSE_PATH && (i.type = f.LINE_TO, i.x = i.relative ? o - a : o, i.y = i.relative ? s - n : s), i.type & f.ARC && (0 === i.rX || 0 === i.rY) && (i.type = f.LINE_TO, delete i.rX, delete i.rY, delete i.xRot, delete i.lArcFlag, delete i.sweepFlag), i;\n    });\n  }, t.NORMALIZE_ST = e, t.QT_TO_C = n, t.INFO = u, t.SANITIZE = function (t) {\n    void 0 === t && (t = 0), a(t);\n    var r = NaN,\n      e = NaN,\n      i = NaN,\n      n = NaN;\n    return u(function (a, o, s, u, h) {\n      var c = Math.abs,\n        y = !1,\n        p = 0,\n        m = 0;\n      if (a.type & f.SMOOTH_CURVE_TO && (p = isNaN(r) ? 0 : o - r, m = isNaN(e) ? 0 : s - e), a.type & (f.CURVE_TO | f.SMOOTH_CURVE_TO) ? (r = a.relative ? o + a.x2 : a.x2, e = a.relative ? s + a.y2 : a.y2) : (r = NaN, e = NaN), a.type & f.SMOOTH_QUAD_TO ? (i = isNaN(i) ? o : 2 * o - i, n = isNaN(n) ? s : 2 * s - n) : a.type & f.QUAD_TO ? (i = a.relative ? o + a.x1 : a.x1, n = a.relative ? s + a.y1 : a.y2) : (i = NaN, n = NaN), a.type & f.LINE_COMMANDS || a.type & f.ARC && (0 === a.rX || 0 === a.rY || !a.lArcFlag) || a.type & f.CURVE_TO || a.type & f.SMOOTH_CURVE_TO || a.type & f.QUAD_TO || a.type & f.SMOOTH_QUAD_TO) {\n        var O = void 0 === a.x ? 0 : a.relative ? a.x : a.x - o,\n          T = void 0 === a.y ? 0 : a.relative ? a.y : a.y - s;\n        p = isNaN(i) ? void 0 === a.x1 ? p : a.relative ? a.x : a.x1 - o : i - o, m = isNaN(n) ? void 0 === a.y1 ? m : a.relative ? a.y : a.y1 - s : n - s;\n        var v = void 0 === a.x2 ? 0 : a.relative ? a.x : a.x2 - o,\n          l = void 0 === a.y2 ? 0 : a.relative ? a.y : a.y2 - s;\n        c(O) <= t && c(T) <= t && c(p) <= t && c(m) <= t && c(v) <= t && c(l) <= t && (y = !0);\n      }\n      return a.type & f.CLOSE_PATH && c(o - u) <= t && c(s - h) <= t && (y = !0), y ? [] : a;\n    });\n  }, t.MATRIX = O, t.ROTATE = function (t, r, e) {\n    void 0 === r && (r = 0), void 0 === e && (e = 0), a(t, r, e);\n    var i = Math.sin(t),\n      n = Math.cos(t);\n    return O(n, i, -i, n, r - r * n + e * i, e - r * i - e * n);\n  }, t.TRANSLATE = function (t, r) {\n    return void 0 === r && (r = 0), a(t, r), O(1, 0, 0, 1, t, r);\n  }, t.SCALE = function (t, r) {\n    return void 0 === r && (r = t), a(t, r), O(t, 0, 0, r, 0, 0);\n  }, t.SKEW_X = function (t) {\n    return a(t), O(1, 0, Math.atan(t), 1, 0, 0);\n  }, t.SKEW_Y = function (t) {\n    return a(t), O(1, Math.atan(t), 0, 1, 0, 0);\n  }, t.X_AXIS_SYMMETRY = function (t) {\n    return void 0 === t && (t = 0), a(t), O(-1, 0, 0, 1, t, 0);\n  }, t.Y_AXIS_SYMMETRY = function (t) {\n    return void 0 === t && (t = 0), a(t), O(1, 0, 0, -1, 0, t);\n  }, t.A_TO_C = function () {\n    return u(function (t, r, e) {\n      return f.ARC === t.type ? function (t, r, e) {\n        var a, n, s, u;\n        t.cX || o(t, r, e);\n        for (var y = Math.min(t.phi1, t.phi2), p = Math.max(t.phi1, t.phi2) - y, m = Math.ceil(p / 90), O = new Array(m), T = r, v = e, l = 0; l < m; l++) {\n          var _ = c(t.phi1, t.phi2, l / m),\n            N = c(t.phi1, t.phi2, (l + 1) / m),\n            x = N - _,\n            d = 4 / 3 * Math.tan(x * h / 4),\n            A = [Math.cos(_ * h) - d * Math.sin(_ * h), Math.sin(_ * h) + d * Math.cos(_ * h)],\n            E = A[0],\n            C = A[1],\n            M = [Math.cos(N * h), Math.sin(N * h)],\n            R = M[0],\n            g = M[1],\n            I = [R + d * Math.sin(N * h), g - d * Math.cos(N * h)],\n            S = I[0],\n            L = I[1];\n          O[l] = {\n            relative: t.relative,\n            type: f.CURVE_TO\n          };\n          var H = function H(r, e) {\n            var a = i([r * t.rX, e * t.rY], t.xRot),\n              n = a[0],\n              o = a[1];\n            return [t.cX + n, t.cY + o];\n          };\n          a = H(E, C), O[l].x1 = a[0], O[l].y1 = a[1], n = H(S, L), O[l].x2 = n[0], O[l].y2 = n[1], s = H(R, g), O[l].x = s[0], O[l].y = s[1], t.relative && (O[l].x1 -= T, O[l].y1 -= v, O[l].x2 -= T, O[l].y2 -= v, O[l].x -= T, O[l].y -= v), T = (u = [O[l].x, O[l].y])[0], v = u[1];\n        }\n        return O;\n      }(t, t.relative ? 0 : r, t.relative ? 0 : e) : t;\n    });\n  }, t.ANNOTATE_ARCS = function () {\n    return u(function (t, r, e) {\n      return t.relative && (r = 0, e = 0), f.ARC === t.type && o(t, r, e), t;\n    });\n  }, t.CLONE = T, t.CALCULATE_BOUNDS = function () {\n    var t = function t(_t2) {\n        var r = {};\n        for (var e in _t2) r[e] = _t2[e];\n        return r;\n      },\n      i = r(),\n      a = n(),\n      h = e(),\n      c = u(function (r, e, n) {\n        var u = h(a(i(t(r))));\n        function O(t) {\n          t > c.maxX && (c.maxX = t), t < c.minX && (c.minX = t);\n        }\n        function T(t) {\n          t > c.maxY && (c.maxY = t), t < c.minY && (c.minY = t);\n        }\n        if (u.type & f.DRAWING_COMMANDS && (O(e), T(n)), u.type & f.HORIZ_LINE_TO && O(u.x), u.type & f.VERT_LINE_TO && T(u.y), u.type & f.LINE_TO && (O(u.x), T(u.y)), u.type & f.CURVE_TO) {\n          O(u.x), T(u.y);\n          for (var v = 0, l = p(e, u.x1, u.x2, u.x); v < l.length; v++) {\n            0 < (w = l[v]) && 1 > w && O(m(e, u.x1, u.x2, u.x, w));\n          }\n          for (var _ = 0, N = p(n, u.y1, u.y2, u.y); _ < N.length; _++) {\n            0 < (w = N[_]) && 1 > w && T(m(n, u.y1, u.y2, u.y, w));\n          }\n        }\n        if (u.type & f.ARC) {\n          O(u.x), T(u.y), o(u, e, n);\n          for (var x = u.xRot / 180 * Math.PI, d = Math.cos(x) * u.rX, A = Math.sin(x) * u.rX, E = -Math.sin(x) * u.rY, C = Math.cos(x) * u.rY, M = u.phi1 < u.phi2 ? [u.phi1, u.phi2] : -180 > u.phi2 ? [u.phi2 + 360, u.phi1 + 360] : [u.phi2, u.phi1], R = M[0], g = M[1], I = function I(t) {\n              var r = t[0],\n                e = t[1],\n                i = 180 * Math.atan2(e, r) / Math.PI;\n              return i < R ? i + 360 : i;\n            }, S = 0, L = s(E, -d, 0).map(I); S < L.length; S++) {\n            (w = L[S]) > R && w < g && O(y(u.cX, d, E, w));\n          }\n          for (var H = 0, U = s(C, -A, 0).map(I); H < U.length; H++) {\n            var w;\n            (w = U[H]) > R && w < g && T(y(u.cY, A, C, w));\n          }\n        }\n        return r;\n      });\n    return c.minX = 1 / 0, c.maxX = -1 / 0, c.minY = 1 / 0, c.maxY = -1 / 0, c;\n  };\n}(u || (u = {}));\nvar O,\n  T = function () {\n    function t() {}\n    return t.prototype.round = function (t) {\n      return this.transform(u.ROUND(t));\n    }, t.prototype.toAbs = function () {\n      return this.transform(u.TO_ABS());\n    }, t.prototype.toRel = function () {\n      return this.transform(u.TO_REL());\n    }, t.prototype.normalizeHVZ = function (t, r, e) {\n      return this.transform(u.NORMALIZE_HVZ(t, r, e));\n    }, t.prototype.normalizeST = function () {\n      return this.transform(u.NORMALIZE_ST());\n    }, t.prototype.qtToC = function () {\n      return this.transform(u.QT_TO_C());\n    }, t.prototype.aToC = function () {\n      return this.transform(u.A_TO_C());\n    }, t.prototype.sanitize = function (t) {\n      return this.transform(u.SANITIZE(t));\n    }, t.prototype.translate = function (t, r) {\n      return this.transform(u.TRANSLATE(t, r));\n    }, t.prototype.scale = function (t, r) {\n      return this.transform(u.SCALE(t, r));\n    }, t.prototype.rotate = function (t, r, e) {\n      return this.transform(u.ROTATE(t, r, e));\n    }, t.prototype.matrix = function (t, r, e, i, a, n) {\n      return this.transform(u.MATRIX(t, r, e, i, a, n));\n    }, t.prototype.skewX = function (t) {\n      return this.transform(u.SKEW_X(t));\n    }, t.prototype.skewY = function (t) {\n      return this.transform(u.SKEW_Y(t));\n    }, t.prototype.xSymmetry = function (t) {\n      return this.transform(u.X_AXIS_SYMMETRY(t));\n    }, t.prototype.ySymmetry = function (t) {\n      return this.transform(u.Y_AXIS_SYMMETRY(t));\n    }, t.prototype.annotateArcs = function () {\n      return this.transform(u.ANNOTATE_ARCS());\n    }, t;\n  }(),\n  v = function v(t) {\n    return \" \" === t || \"\\t\" === t || \"\\r\" === t || \"\\n\" === t;\n  },\n  l = function l(t) {\n    return \"0\".charCodeAt(0) <= t.charCodeAt(0) && t.charCodeAt(0) <= \"9\".charCodeAt(0);\n  },\n  _ = function (t) {\n    function e() {\n      var r = t.call(this) || this;\n      return r.curNumber = \"\", r.curCommandType = -1, r.curCommandRelative = !1, r.canParseCommandOrComma = !0, r.curNumberHasExp = !1, r.curNumberHasExpDigits = !1, r.curNumberHasDecimal = !1, r.curArgs = [], r;\n    }\n    return r(e, t), e.prototype.finish = function (t) {\n      if (void 0 === t && (t = []), this.parse(\" \", t), 0 !== this.curArgs.length || !this.canParseCommandOrComma) throw new SyntaxError(\"Unterminated command at the path end.\");\n      return t;\n    }, e.prototype.parse = function (t, r) {\n      var e = this;\n      void 0 === r && (r = []);\n      for (var i = function i(t) {\n          r.push(t), e.curArgs.length = 0, e.canParseCommandOrComma = !0;\n        }, a = 0; a < t.length; a++) {\n        var n = t[a],\n          o = !(this.curCommandType !== f.ARC || 3 !== this.curArgs.length && 4 !== this.curArgs.length || 1 !== this.curNumber.length || \"0\" !== this.curNumber && \"1\" !== this.curNumber),\n          s = l(n) && (\"0\" === this.curNumber && \"0\" === n || o);\n        if (!l(n) || s) {\n          if (\"e\" !== n && \"E\" !== n) {\n            if (\"-\" !== n && \"+\" !== n || !this.curNumberHasExp || this.curNumberHasExpDigits) {\n              if (\".\" !== n || this.curNumberHasExp || this.curNumberHasDecimal || o) {\n                if (this.curNumber && -1 !== this.curCommandType) {\n                  var u = Number(this.curNumber);\n                  if (isNaN(u)) throw new SyntaxError(\"Invalid number ending at \" + a);\n                  if (this.curCommandType === f.ARC) if (0 === this.curArgs.length || 1 === this.curArgs.length) {\n                    if (0 > u) throw new SyntaxError('Expected positive number, got \"' + u + '\" at index \"' + a + '\"');\n                  } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && \"0\" !== this.curNumber && \"1\" !== this.curNumber) throw new SyntaxError('Expected a flag, got \"' + this.curNumber + '\" at index \"' + a + '\"');\n                  this.curArgs.push(u), this.curArgs.length === N[this.curCommandType] && (f.HORIZ_LINE_TO === this.curCommandType ? i({\n                    type: f.HORIZ_LINE_TO,\n                    relative: this.curCommandRelative,\n                    x: u\n                  }) : f.VERT_LINE_TO === this.curCommandType ? i({\n                    type: f.VERT_LINE_TO,\n                    relative: this.curCommandRelative,\n                    y: u\n                  }) : this.curCommandType === f.MOVE_TO || this.curCommandType === f.LINE_TO || this.curCommandType === f.SMOOTH_QUAD_TO ? (i({\n                    type: this.curCommandType,\n                    relative: this.curCommandRelative,\n                    x: this.curArgs[0],\n                    y: this.curArgs[1]\n                  }), f.MOVE_TO === this.curCommandType && (this.curCommandType = f.LINE_TO)) : this.curCommandType === f.CURVE_TO ? i({\n                    type: f.CURVE_TO,\n                    relative: this.curCommandRelative,\n                    x1: this.curArgs[0],\n                    y1: this.curArgs[1],\n                    x2: this.curArgs[2],\n                    y2: this.curArgs[3],\n                    x: this.curArgs[4],\n                    y: this.curArgs[5]\n                  }) : this.curCommandType === f.SMOOTH_CURVE_TO ? i({\n                    type: f.SMOOTH_CURVE_TO,\n                    relative: this.curCommandRelative,\n                    x2: this.curArgs[0],\n                    y2: this.curArgs[1],\n                    x: this.curArgs[2],\n                    y: this.curArgs[3]\n                  }) : this.curCommandType === f.QUAD_TO ? i({\n                    type: f.QUAD_TO,\n                    relative: this.curCommandRelative,\n                    x1: this.curArgs[0],\n                    y1: this.curArgs[1],\n                    x: this.curArgs[2],\n                    y: this.curArgs[3]\n                  }) : this.curCommandType === f.ARC && i({\n                    type: f.ARC,\n                    relative: this.curCommandRelative,\n                    rX: this.curArgs[0],\n                    rY: this.curArgs[1],\n                    xRot: this.curArgs[2],\n                    lArcFlag: this.curArgs[3],\n                    sweepFlag: this.curArgs[4],\n                    x: this.curArgs[5],\n                    y: this.curArgs[6]\n                  })), this.curNumber = \"\", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;\n                }\n                if (!v(n)) if (\",\" === n && this.canParseCommandOrComma) this.canParseCommandOrComma = !1;else if (\"+\" !== n && \"-\" !== n && \".\" !== n) {\n                  if (s) this.curNumber = n, this.curNumberHasDecimal = !1;else {\n                    if (0 !== this.curArgs.length) throw new SyntaxError(\"Unterminated command at index \" + a + \".\");\n                    if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character \"' + n + '\" at index ' + a + \". Command cannot follow comma\");\n                    if (this.canParseCommandOrComma = !1, \"z\" !== n && \"Z\" !== n) {\n                      if (\"h\" === n || \"H\" === n) this.curCommandType = f.HORIZ_LINE_TO, this.curCommandRelative = \"h\" === n;else if (\"v\" === n || \"V\" === n) this.curCommandType = f.VERT_LINE_TO, this.curCommandRelative = \"v\" === n;else if (\"m\" === n || \"M\" === n) this.curCommandType = f.MOVE_TO, this.curCommandRelative = \"m\" === n;else if (\"l\" === n || \"L\" === n) this.curCommandType = f.LINE_TO, this.curCommandRelative = \"l\" === n;else if (\"c\" === n || \"C\" === n) this.curCommandType = f.CURVE_TO, this.curCommandRelative = \"c\" === n;else if (\"s\" === n || \"S\" === n) this.curCommandType = f.SMOOTH_CURVE_TO, this.curCommandRelative = \"s\" === n;else if (\"q\" === n || \"Q\" === n) this.curCommandType = f.QUAD_TO, this.curCommandRelative = \"q\" === n;else if (\"t\" === n || \"T\" === n) this.curCommandType = f.SMOOTH_QUAD_TO, this.curCommandRelative = \"t\" === n;else {\n                        if (\"a\" !== n && \"A\" !== n) throw new SyntaxError('Unexpected character \"' + n + '\" at index ' + a + \".\");\n                        this.curCommandType = f.ARC, this.curCommandRelative = \"a\" === n;\n                      }\n                    } else r.push({\n                      type: f.CLOSE_PATH\n                    }), this.canParseCommandOrComma = !0, this.curCommandType = -1;\n                  }\n                } else this.curNumber = n, this.curNumberHasDecimal = \".\" === n;\n              } else this.curNumber += n, this.curNumberHasDecimal = !0;\n            } else this.curNumber += n;\n          } else this.curNumber += n, this.curNumberHasExp = !0;\n        } else this.curNumber += n, this.curNumberHasExpDigits = this.curNumberHasExp;\n      }\n      return r;\n    }, e.prototype.transform = function (t) {\n      return Object.create(this, {\n        parse: {\n          value: function value(r, e) {\n            void 0 === e && (e = []);\n            for (var i = 0, a = Object.getPrototypeOf(this).parse.call(this, r); i < a.length; i++) {\n              var n = a[i],\n                o = t(n);\n              Array.isArray(o) ? e.push.apply(e, o) : e.push(o);\n            }\n            return e;\n          }\n        }\n      });\n    }, e;\n  }(T),\n  f = function (t) {\n    function i(r) {\n      var e = t.call(this) || this;\n      return e.commands = \"string\" == typeof r ? i.parse(r) : r, e;\n    }\n    return r(i, t), i.prototype.encode = function () {\n      return i.encode(this.commands);\n    }, i.prototype.getBounds = function () {\n      var t = u.CALCULATE_BOUNDS();\n      return this.transform(t), t;\n    }, i.prototype.transform = function (t) {\n      for (var r = [], e = 0, i = this.commands; e < i.length; e++) {\n        var a = t(i[e]);\n        Array.isArray(a) ? r.push.apply(r, a) : r.push(a);\n      }\n      return this.commands = r, this;\n    }, i.encode = function (t) {\n      return e(t);\n    }, i.parse = function (t) {\n      var r = new _(),\n        e = [];\n      return r.parse(t, e), r.finish(e), e;\n    }, i.CLOSE_PATH = 1, i.MOVE_TO = 2, i.HORIZ_LINE_TO = 4, i.VERT_LINE_TO = 8, i.LINE_TO = 16, i.CURVE_TO = 32, i.SMOOTH_CURVE_TO = 64, i.QUAD_TO = 128, i.SMOOTH_QUAD_TO = 256, i.ARC = 512, i.LINE_COMMANDS = i.LINE_TO | i.HORIZ_LINE_TO | i.VERT_LINE_TO, i.DRAWING_COMMANDS = i.HORIZ_LINE_TO | i.VERT_LINE_TO | i.LINE_TO | i.CURVE_TO | i.SMOOTH_CURVE_TO | i.QUAD_TO | i.SMOOTH_QUAD_TO | i.ARC, i;\n  }(T),\n  N = ((O = {})[f.MOVE_TO] = 2, O[f.LINE_TO] = 2, O[f.HORIZ_LINE_TO] = 1, O[f.VERT_LINE_TO] = 1, O[f.CLOSE_PATH] = 0, O[f.QUAD_TO] = 4, O[f.SMOOTH_QUAD_TO] = 2, O[f.CURVE_TO] = 6, O[f.SMOOTH_CURVE_TO] = 4, O[f.ARC] = 7, O);\nexport { N as COMMAND_ARG_COUNTS, f as SVGPathData, _ as SVGPathDataParser, u as SVGPathDataTransformer, e as encodeSVGPath };","map":{"version":3,"names":["e","t","r","Array","isArray","length","i","type","f","CLOSE_PATH","HORIZ_LINE_TO","relative","x","VERT_LINE_TO","y","MOVE_TO","LINE_TO","CURVE_TO","x1","y1","x2","y2","SMOOTH_CURVE_TO","QUAD_TO","SMOOTH_QUAD_TO","ARC","Error","rX","rY","xRot","lArcFlag","sweepFlag","Math","cos","sin","a","arguments","n","PI","o","s","u","abs","h","c","p","pow","sqrt","m","O","max","T","v","l","cX","cY","phi1","atan2","phi2","NaN","isNaN","_","N","d","A","E","C","M","R","g","I","S","L","ROUND","round","TO_ABS","TO_REL","NORMALIZE_HVZ","NORMALIZE_ST","QT_TO_C","INFO","SANITIZE","LINE_COMMANDS","MATRIX","ROTATE","TRANSLATE","SCALE","SKEW_X","atan","SKEW_Y","X_AXIS_SYMMETRY","Y_AXIS_SYMMETRY","A_TO_C","min","ceil","tan","H","ANNOTATE_ARCS","CLONE","CALCULATE_BOUNDS","maxX","minX","maxY","minY","DRAWING_COMMANDS","w","map","U","prototype","transform","toAbs","toRel","normalizeHVZ","normalizeST","qtToC","aToC","sanitize","translate","scale","rotate","matrix","skewX","skewY","xSymmetry","ySymmetry","annotateArcs","charCodeAt","call","curNumber","curCommandType","curCommandRelative","canParseCommandOrComma","curNumberHasExp","curNumberHasExpDigits","curNumberHasDecimal","curArgs","finish","parse","SyntaxError","push","Number","Object","create","value","getPrototypeOf","apply","commands","encode","getBounds","COMMAND_ARG_COUNTS","SVGPathData","SVGPathDataParser","SVGPathDataTransformer","encodeSVGPath"],"sources":["E:\\invoice-generator\\node_modules\\svg-pathdata\\src\\SVGPathDataEncoder.ts","E:\\invoice-generator\\node_modules\\svg-pathdata\\src\\mathUtils.ts","E:\\invoice-generator\\node_modules\\svg-pathdata\\src\\SVGPathDataTransformer.ts","E:\\invoice-generator\\node_modules\\svg-pathdata\\src\\TransformableSVG.ts","E:\\invoice-generator\\node_modules\\svg-pathdata\\src\\SVGPathDataParser.ts","E:\\invoice-generator\\node_modules\\svg-pathdata\\src\\SVGPathData.ts"],"sourcesContent":["import { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand } from \"./types\";\n\n// Encode SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\n// Private consts : Char groups\nconst WSP = \" \";\n\nexport function encodeSVGPath(commands: SVGCommand | SVGCommand[]) {\n  let str = \"\";\n\n  if (!Array.isArray(commands)) {\n    commands = [commands];\n  }\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    if (command.type === SVGPathData.CLOSE_PATH) {\n      str += \"z\";\n    } else if (command.type === SVGPathData.HORIZ_LINE_TO) {\n      str += (command.relative ? \"h\" : \"H\") +\n        command.x;\n    } else if (command.type === SVGPathData.VERT_LINE_TO) {\n      str += (command.relative ? \"v\" : \"V\") +\n        command.y;\n    } else if (command.type === SVGPathData.MOVE_TO) {\n      str += (command.relative ? \"m\" : \"M\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.LINE_TO) {\n      str += (command.relative ? \"l\" : \"L\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.CURVE_TO) {\n      str += (command.relative ? \"c\" : \"C\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_CURVE_TO) {\n      str += (command.relative ? \"s\" : \"S\") +\n        command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.QUAD_TO) {\n      str += (command.relative ? \"q\" : \"Q\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_QUAD_TO) {\n      str += (command.relative ? \"t\" : \"T\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.ARC) {\n      str += (command.relative ? \"a\" : \"A\") +\n        command.rX + WSP + command.rY +\n        WSP + command.xRot +\n        WSP + (+command.lArcFlag) + WSP + (+command.sweepFlag) +\n        WSP + command.x + WSP + command.y;\n    } else {\n      // Unknown command\n      throw new Error(\n        `Unexpected command type \"${ (command as any).type}\" at index ${i}.`);\n    }\n  }\n\n  return str;\n}\n","import { SVGPathData } from \"./SVGPathData\";\nimport { CommandA, CommandC } from \"./types\";\n\nexport function rotate([x, y]: [number, number], rad: number) {\n  return [\n    x * Math.cos(rad) - y * Math.sin(rad),\n    x * Math.sin(rad) + y * Math.cos(rad),\n  ];\n}\n\nconst DEBUG_CHECK_NUMBERS = true;\nexport function assertNumbers(...numbers: number[]) {\n  if (DEBUG_CHECK_NUMBERS) {\n    for (let i = 0; i < numbers.length; i++) {\n      if (\"number\" !== typeof numbers[i]) {\n        throw new Error(\n          `assertNumbers arguments[${i}] is not a number. ${typeof numbers[i]} == typeof ${numbers[i]}`);\n      }\n    }\n  }\n  return true;\n}\n\nconst PI = Math.PI;\n\n/**\n * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n * Fixes rX and rY.\n * Ensures lArcFlag and sweepFlag are 0 or 1\n * Adds center coordinates: command.cX, command.cY (relative or absolute, depending on command.relative)\n * Adds start and end arc parameters (in degrees): command.phi1, command.phi2; phi1 < phi2 iff. c.sweepFlag == true\n */\nexport function annotateArcCommand(c: CommandA, x1: number, y1: number) {\n  c.lArcFlag = (0 === c.lArcFlag) ? 0 : 1;\n  c.sweepFlag = (0 === c.sweepFlag) ? 0 : 1;\n  // tslint:disable-next-line\n  let {rX, rY, x, y} = c;\n\n  rX = Math.abs(c.rX);\n  rY = Math.abs(c.rY);\n  const [x1_, y1_] = rotate([(x1 - x) / 2, (y1 - y) / 2], -c.xRot / 180 * PI);\n  const testValue = Math.pow(x1_, 2) / Math.pow(rX, 2) + Math.pow(y1_, 2) / Math.pow(rY, 2);\n\n  if (1 < testValue) {\n    rX *= Math.sqrt(testValue);\n    rY *= Math.sqrt(testValue);\n  }\n  c.rX = rX;\n  c.rY = rY;\n  const c_ScaleTemp = (Math.pow(rX, 2) * Math.pow(y1_, 2) + Math.pow(rY, 2) * Math.pow(x1_, 2));\n  const c_Scale = (c.lArcFlag !== c.sweepFlag ? 1 : -1) *\n    Math.sqrt(Math.max(0, (Math.pow(rX, 2) * Math.pow(rY, 2) - c_ScaleTemp) / c_ScaleTemp));\n  const cx_ = rX * y1_ / rY * c_Scale;\n  const cy_ = -rY * x1_ / rX * c_Scale;\n  const cRot = rotate([cx_, cy_], c.xRot / 180 * PI);\n\n  c.cX = cRot[0] + (x1 + x) / 2;\n  c.cY = cRot[1] + (y1 + y) / 2;\n  c.phi1 = Math.atan2((y1_ - cy_) / rY, (x1_ - cx_) / rX);\n  c.phi2 = Math.atan2((-y1_ - cy_) / rY, (-x1_ - cx_) / rX);\n  if (0 === c.sweepFlag && c.phi2 > c.phi1) {\n    c.phi2 -= 2 * PI;\n  }\n  if (1 === c.sweepFlag && c.phi2 < c.phi1) {\n    c.phi2 += 2 * PI;\n  }\n  c.phi1 *= 180 / PI;\n  c.phi2 *= 180 / PI;\n}\n\n/**\n * Solves a quadratic system of equations of the form\n *      a * x + b * y = c\n *      x² + y² = 1\n * This can be understood as the intersection of the unit circle with a line.\n *      => y = (c - a x) / b\n *      => x² + (c - a x)² / b² = 1\n *      => x² b² + c² - 2 c a x + a² x² = b²\n *      => (a² + b²) x² - 2 a c x + (c² - b²) = 0\n */\nexport function intersectionUnitCircleLine(a: number, b: number, c: number): [number, number][] {\n  assertNumbers(a, b, c);\n  // cf. pqFormula\n  const termSqr = a * a + b * b - c * c;\n\n  if (0 > termSqr) {\n    return [];\n  } else if (0 === termSqr) {\n    return [\n      [\n        (a * c) / (a * a + b * b),\n        (b * c) / (a * a + b * b)]];\n  }\n  const term = Math.sqrt(termSqr);\n\n  return [\n    [\n      (a * c + b * term) / (a * a + b * b),\n      (b * c - a * term) / (a * a + b * b)],\n    [\n      (a * c - b * term) / (a * a + b * b),\n      (b * c + a * term) / (a * a + b * b)]];\n\n}\n\nexport const DEG = Math.PI / 180;\n\nexport function lerp(a: number, b: number, t: number) {\n  return (1 - t) * a + t * b;\n}\n\nexport function arcAt(c: number, x1: number, x2: number, phiDeg: number) {\n  return c + Math.cos(phiDeg / 180 * PI) * x1 + Math.sin(phiDeg / 180 * PI) * x2;\n}\n\nexport function bezierRoot(x0: number, x1: number, x2: number, x3: number) {\n  const EPS = 1e-6;\n  const x01 = x1 - x0;\n  const x12 = x2 - x1;\n  const x23 = x3 - x2;\n  const a = 3 * x01 + 3 * x23 - 6 * x12;\n  const b = (x12 - x01) * 6;\n  const c = 3 * x01;\n  // solve a * t² + b * t + c = 0\n\n  if (Math.abs(a) < EPS) {\n    // equivalent to b * t + c =>\n    return [-c / b];\n  }\n  return pqFormula(b / a, c / a, EPS);\n\n}\n\nexport function bezierAt(x0: number, x1: number, x2: number, x3: number, t: number) {\n  // console.log(x0, y0, x1, y1, x2, y2, x3, y3, t)\n  const s = 1 - t;\n  const c0 = s * s * s;\n  const c1 = 3 * s * s * t;\n  const c2 = 3 * s * t * t;\n  const c3 = t * t * t;\n\n  return x0 * c0 + x1 * c1 + x2 * c2 + x3 * c3;\n}\n\nfunction pqFormula(p: number, q: number, PRECISION = 1e-6) {\n  // 4 times the discriminant:in\n  const discriminantX4 = p * p / 4 - q;\n\n  if (discriminantX4 < -PRECISION) {\n    return [];\n  } else if (discriminantX4 <= PRECISION) {\n    return [-p / 2];\n  }\n  const root = Math.sqrt(discriminantX4);\n\n  return [-(p / 2) - root, -(p / 2) + root];\n\n}\n\nexport function a2c(arc: CommandA, x0: number, y0: number): CommandC[] {\n  if (!arc.cX) {\n    annotateArcCommand(arc, x0, y0);\n  }\n\n  const phiMin = Math.min(arc.phi1!, arc.phi2!), phiMax = Math.max(arc.phi1!, arc.phi2!), deltaPhi = phiMax - phiMin;\n  const partCount = Math.ceil(deltaPhi / 90 );\n\n  const result: CommandC[] = new Array(partCount);\n  let prevX = x0, prevY = y0;\n  for (let i = 0; i < partCount; i++) {\n    const phiStart = lerp(arc.phi1!, arc.phi2!, i / partCount);\n    const phiEnd = lerp(arc.phi1!, arc.phi2!, (i + 1) / partCount);\n    const deltaPhi = phiEnd - phiStart;\n    const f = 4 / 3 * Math.tan(deltaPhi * DEG / 4);\n    // x1/y1, x2/y2 and x/y coordinates on the unit circle for phiStart/phiEnd\n    const [x1, y1] = [\n      Math.cos(phiStart * DEG) - f * Math.sin(phiStart * DEG),\n      Math.sin(phiStart * DEG) + f * Math.cos(phiStart * DEG)];\n    const [x, y] = [Math.cos(phiEnd * DEG), Math.sin(phiEnd * DEG)];\n    const [x2, y2] = [x + f * Math.sin(phiEnd * DEG), y - f * Math.cos(phiEnd * DEG)];\n    result[i] = {relative: arc.relative, type: SVGPathData.CURVE_TO } as any;\n    const transform = (x: number, y: number) => {\n      const [xTemp, yTemp] = rotate([x * arc.rX, y * arc.rY], arc.xRot);\n      return [arc.cX! + xTemp, arc.cY! + yTemp];\n    };\n    [result[i].x1, result[i].y1] = transform(x1, y1);\n    [result[i].x2, result[i].y2] = transform(x2, y2);\n    [result[i].x, result[i].y] = transform(x, y);\n    if (arc.relative) {\n      result[i].x1 -= prevX;\n      result[i].y1 -= prevY;\n      result[i].x2 -= prevX;\n      result[i].y2 -= prevY;\n      result[i].x -= prevX;\n      result[i].y -= prevY;\n    }\n    [prevX, prevY] = [result[i].x, result[i].y];\n  }\n  return result;\n}\n","// Transform SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\nimport { a2c, annotateArcCommand, arcAt, assertNumbers, bezierAt, bezierRoot,\n  intersectionUnitCircleLine } from \"./mathUtils\";\nimport { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand, TransformFunction } from \"./types\";\n\nexport namespace SVGPathDataTransformer {\n  // Predefined transforming functions\n  // Rounds commands values\n  export function ROUND(roundVal = 1e13) {\n    assertNumbers(roundVal);\n    function rf(val: number) { return Math.round(val * roundVal) / roundVal; }\n    return function round(command: any) {\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = rf(command.x1);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = rf(command.y1);\n      }\n\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = rf(command.x2);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = rf(command.y2);\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = rf(command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = rf(command.y);\n      }\n\n      if (\"undefined\" !== typeof command.rX) {\n        command.rX = rf(command.rX);\n      }\n      if (\"undefined\" !== typeof command.rY) {\n        command.rY = rf(command.rY);\n      }\n\n      return command;\n    };\n  }\n  // Relative to absolute commands\n  export function TO_ABS() {\n    return INFO((command, prevX, prevY) => {\n      if (command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 += prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 += prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x += prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y += prevY;\n        }\n        command.relative = false;\n      }\n      return command;\n    });\n  }\n  // Absolute to relative commands\n  export function TO_REL() {\n    return INFO((command, prevX, prevY) => {\n      if (!command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 -= prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 -= prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y -= prevY;\n        }\n        command.relative = true;\n      }\n      return command;\n    });\n  }\n  // Convert H, V, Z and A with rX = 0 to L\n  export function NORMALIZE_HVZ(normalizeZ = true, normalizeH = true, normalizeV = true) {\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n      if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n      if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? pathStartX - prevX : pathStartX;\n        command.y = command.relative ? pathStartY - prevY : pathStartY;\n      }\n      if (command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY)) {\n        command.type = SVGPathData.LINE_TO;\n        delete command.rX;\n        delete command.rY;\n        delete command.xRot;\n        delete command.lArcFlag;\n        delete command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  /*\n   * Transforms smooth curves and quads to normal curves and quads (SsTt to CcQq)\n   */\n  export function NORMALIZE_ST() {\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        command.type = SVGPathData.CURVE_TO;\n        prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;\n        prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;\n        command.x1 = command.relative ? prevX - prevCurveC2X : 2 * prevX - prevCurveC2X;\n        command.y1 = command.relative ? prevY - prevCurveC2Y : 2 * prevY - prevCurveC2Y;\n      }\n      if (command.type & SVGPathData.CURVE_TO) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;\n        command.x1 = command.relative ? prevX - prevQuadCX : 2 * prevX - prevQuadCX;\n        command.y1 = command.relative ? prevY - prevQuadCY : 2 * prevY - prevQuadCY;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y1;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      return command;\n    });\n  }\n  /*\n   * A quadratic bézier curve can be represented by a cubic bézier curve which has\n   * the same end points as the quadratic and both control points in place of the\n   * quadratic\"s one.\n   *\n   * This transformer replaces QqTt commands with Cc commands respectively.\n   * This is useful for reading path data into a system which only has a\n   * representation for cubic curves.\n   */\n  export function QT_TO_C() {\n    let prevQuadX1 = NaN;\n    let prevQuadY1 = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;\n        prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;\n        command.x1 = command.relative ? prevX - prevQuadX1 : 2 * prevX - prevQuadX1;\n        command.y1 = command.relative ? prevY - prevQuadY1 : 2 * prevY - prevQuadY1;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;\n        const x1 = command.x1;\n        const y1 = command.y1;\n\n        command.type = SVGPathData.CURVE_TO;\n        command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;\n        command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;\n        command.x2 = (command.x + x1 * 2) / 3;\n        command.y2 = (command.y + y1 * 2) / 3;\n      } else {\n        prevQuadX1 = NaN;\n        prevQuadY1 = NaN;\n      }\n\n      return command;\n    });\n  }\n  export function INFO(\n    f: (command: any, prevXAbs: number, prevYAbs: number,\n        pathStartXAbs: number, pathStartYAbs: number) => any | any[]) {\n    let prevXAbs = 0;\n    let prevYAbs = 0;\n    let pathStartXAbs = NaN;\n    let pathStartYAbs = NaN;\n\n    return function transform(command: any) {\n      if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n\n      const result = f(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        prevXAbs = pathStartXAbs;\n        prevYAbs = pathStartYAbs;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        prevXAbs = (command.relative ? prevXAbs + command.x : command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        prevYAbs = (command.relative ? prevYAbs + command.y : command.y);\n      }\n\n      if (command.type & SVGPathData.MOVE_TO) {\n        pathStartXAbs = prevXAbs;\n        pathStartYAbs = prevYAbs;\n      }\n\n      return result;\n    };\n  }\n  /*\n   * remove 0-length segments\n   */\n  export function SANITIZE(EPS = 0) {\n    assertNumbers(EPS);\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      const abs = Math.abs;\n      let skip = false;\n      let x1Rel = 0;\n      let y1Rel = 0;\n\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;\n        y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;\n      }\n      if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;\n      } else if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y2;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      if (command.type & SVGPathData.LINE_COMMANDS ||\n        command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY || !command.lArcFlag) ||\n        command.type & SVGPathData.CURVE_TO || command.type & SVGPathData.SMOOTH_CURVE_TO ||\n        command.type & SVGPathData.QUAD_TO || command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        const xRel = \"undefined\" === typeof command.x ? 0 :\n          (command.relative ? command.x : command.x - prevX);\n        const yRel = \"undefined\" === typeof command.y ? 0 :\n          (command.relative ? command.y : command.y - prevY);\n\n        x1Rel = !isNaN(prevQuadCX) ? prevQuadCX - prevX :\n          \"undefined\" === typeof command.x1 ? x1Rel :\n            command.relative ? command.x :\n              command.x1 - prevX;\n        y1Rel = !isNaN(prevQuadCY) ? prevQuadCY - prevY :\n          \"undefined\" === typeof command.y1 ? y1Rel :\n            command.relative ? command.y :\n              command.y1 - prevY;\n\n        const x2Rel = \"undefined\" === typeof command.x2 ? 0 :\n          (command.relative ? command.x : command.x2 - prevX);\n        const y2Rel = \"undefined\" === typeof command.y2 ? 0 :\n          (command.relative ? command.y : command.y2 - prevY);\n\n        if (abs(xRel) <= EPS && abs(yRel) <= EPS &&\n          abs(x1Rel) <= EPS && abs(y1Rel) <= EPS &&\n          abs(x2Rel) <= EPS && abs(y2Rel) <= EPS) {\n          skip = true;\n        }\n      }\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) {\n          skip = true;\n        }\n      }\n\n      return skip ? [] : command;\n    });\n  }\n  // SVG Transforms : http://www.w3.org/TR/SVGTiny12/coords.html#TransformList\n  // Matrix : http://apike.ca/prog_svg_transform.html\n  // a c e\n  // b d f\n  export function MATRIX(a: number, b: number, c: number, d: number, e: number, f: number) {\n    assertNumbers(a, b, c, d, e, f);\n\n    return INFO((command, prevX, prevY, pathStartX) => {\n      const origX1 = command.x1;\n      const origX2 = command.x2;\n      // if isNaN(pathStartX), then this is the first command, which is ALWAYS an\n      // absolute MOVE_TO, regardless what the relative flag says\n      const comRel = command.relative && !isNaN(pathStartX);\n      const x = \"undefined\" !== typeof command.x ? command.x : (comRel ? 0 : prevX);\n      const y = \"undefined\" !== typeof command.y ? command.y : (comRel ? 0 : prevY);\n\n      if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = (command.x * a) + (y * c) + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = (x * b) + command.y * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = command.x1 * a + command.y1 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = origX1 * b + command.y1 * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = command.x2 * a + command.y2 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = origX2 * b + command.y2 * d + (comRel ? 0 : f);\n      }\n      function sqr(x: number) { return x * x; }\n      const det = a * d - b * c;\n\n      if (\"undefined\" !== typeof command.xRot) {\n        // Skip if this is a pure translation\n        if (1 !== a || 0 !== b || 0 !== c || 1 !== d) {\n          // Special case for singular matrix\n          if (0 === det) {\n            // In the singular case, the arc is compressed to a line. The actual geometric image of the original\n            // curve under this transform possibly extends beyond the starting and/or ending points of the segment, but\n            // for simplicity we ignore this detail and just replace this command with a single line segment.\n            delete command.rX;\n            delete command.rY;\n            delete command.xRot;\n            delete command.lArcFlag;\n            delete command.sweepFlag;\n            command.type = SVGPathData.LINE_TO;\n          } else {\n            // Convert to radians\n            const xRot = command.xRot * Math.PI / 180;\n\n            // Convert rotated ellipse to general conic form\n            // x0^2/rX^2 + y0^2/rY^2 - 1 = 0\n            // x0 = x*cos(xRot) + y*sin(xRot)\n            // y0 = -x*sin(xRot) + y*cos(xRot)\n            // --> A*x^2 + B*x*y + C*y^2 - 1 = 0, where\n            const sinRot = Math.sin(xRot);\n            const cosRot = Math.cos(xRot);\n            const xCurve = 1 / sqr(command.rX);\n            const yCurve = 1 / sqr(command.rY);\n            const A = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;\n            const B = 2 * sinRot * cosRot * (xCurve - yCurve);\n            const C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;\n\n            // Apply matrix to A*x^2 + B*x*y + C*y^2 - 1 = 0\n            // x1 = a*x + c*y\n            // y1 = b*x + d*y\n            //      (we can ignore e and f, since pure translations don\"t affect the shape of the ellipse)\n            // --> A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 = 0, where\n            const A1 = A * d * d - B * b * d + C * b * b;\n            const B1 = B * (a * d + b * c) - 2 * (A * c * d + C * a * b);\n            const C1 = A * c * c - B * a * c + C * a * a;\n\n            // Unapply newXRot to get back to axis-aligned ellipse equation\n            // x1 = x2*cos(newXRot) - y2*sin(newXRot)\n            // y1 = x2*sin(newXRot) + y2*cos(newXRot)\n            // A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 =\n            //   x2^2*(A1*cos(newXRot)^2 + B1*sin(newXRot)*cos(newXRot) + C1*sin(newXRot)^2)\n            //   + x2*y2*(2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2))\n            //   + y2^2*(A1*sin(newXRot)^2 - B1*sin(newXRot)*cos(newXRot) + C1*cos(newXRot)^2)\n            //   (which must have the same zeroes as)\n            // x2^2/newRX^2 + y2^2/newRY^2 - 1\n            //   (so we have)\n            // 2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2) = 0\n            // (A1 - C1)*sin(2*newXRot) = B1*cos(2*newXRot)\n            // 2*newXRot = atan2(B1, A1 - C1)\n            const newXRot = ((Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI) / 2;\n            // For any integer n, (atan2(B1, A1 - C1) + n*pi)/2 is a solution to the above; incrementing n just swaps\n            // the x and y radii computed below (since that\"s what rotating an ellipse by pi/2 does).  Choosing the\n            // rotation between 0 and pi/2 eliminates the ambiguity and leads to more predictable output.\n\n            // Finally, we get newRX and newRY from the same-zeroes relationship that gave us newXRot\n            const newSinRot = Math.sin(newXRot);\n            const newCosRot = Math.cos(newXRot);\n\n            command.rX = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newCosRot) + B1 * newSinRot * newCosRot + C1 * sqr(newSinRot));\n            command.rY = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newSinRot) - B1 * newSinRot * newCosRot + C1 * sqr(newCosRot));\n            command.xRot = newXRot * 180 / Math.PI;\n          }\n        }\n      }\n      // sweepFlag needs to be inverted when mirroring shapes\n      // see http://www.itk.ilstu.edu/faculty/javila/SVG/SVG_drawing1/elliptical_curve.htm\n      // m 65,10 a 50,25 0 1 0 50,25\n      // M 65,60 A 50,25 0 1 1 115,35\n      if (\"undefined\" !== typeof command.sweepFlag && 0 > det) {\n        command.sweepFlag = +!command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  export function ROTATE(a: number, x = 0, y = 0) {\n    assertNumbers(a, x, y);\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    return MATRIX(cos, sin, -sin, cos, x - x * cos + y * sin, y - x * sin - y * cos);\n  }\n  export function TRANSLATE(dX: number, dY = 0) {\n    assertNumbers(dX, dY);\n    return MATRIX(1, 0, 0, 1, dX, dY);\n  }\n  export function SCALE(dX: number, dY = dX) {\n    assertNumbers(dX, dY);\n    return MATRIX(dX, 0, 0, dY, 0, 0);\n  }\n  export function SKEW_X(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, 0, Math.atan(a), 1, 0, 0);\n  }\n  export function SKEW_Y(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, Math.atan(a), 0, 1, 0, 0);\n  }\n  export function X_AXIS_SYMMETRY(xOffset = 0) {\n    assertNumbers(xOffset);\n    return MATRIX(-1, 0, 0, 1, xOffset, 0);\n  }\n  export function Y_AXIS_SYMMETRY(yOffset = 0) {\n    assertNumbers(yOffset);\n    return MATRIX(1, 0, 0, -1, 0, yOffset);\n  }\n  // Convert arc commands to curve commands\n  export function A_TO_C() {\n    return INFO((command, prevX, prevY) => {\n      if (SVGPathData.ARC === command.type) {\n        return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);\n      }\n      return command;\n    });\n  }\n  // @see annotateArcCommand\n  export function ANNOTATE_ARCS() {\n    return INFO((c, x1, y1) => {\n      if (c.relative) {\n        x1 = 0;\n        y1 = 0;\n      }\n      if (SVGPathData.ARC === c.type) {\n        annotateArcCommand(c, x1, y1);\n      }\n      return c;\n    });\n  }\n  export function CLONE() {\n    return (c: SVGCommand) => {\n      const result = {} as SVGCommand;\n      // tslint:disable-next-line\n      for (const key in c) {\n        result[key as keyof SVGCommand] = c[key as keyof SVGCommand];\n      }\n      return result;\n    };\n  }\n  // @see annotateArcCommand\n  export function CALCULATE_BOUNDS() {\n    const clone = CLONE();\n    const toAbs = TO_ABS();\n    const qtToC = QT_TO_C();\n    const normST = NORMALIZE_ST();\n    const f: TransformFunction & {minX: number, maxX: number, minY: number, maxY: number} =\n        INFO((command, prevXAbs, prevYAbs) => {\n      const c = normST(qtToC(toAbs(clone(command))));\n      function fixX(absX: number) {\n        if (absX > f.maxX) { f.maxX = absX; }\n        if (absX < f.minX) { f.minX = absX; }\n      }\n      function fixY(absY: number) {\n        if (absY > f.maxY) { f.maxY = absY; }\n        if (absY < f.minY) { f.minY = absY; }\n      }\n      if (c.type & SVGPathData.DRAWING_COMMANDS) {\n        fixX(prevXAbs);\n        fixY(prevYAbs);\n      }\n      if (c.type & SVGPathData.HORIZ_LINE_TO) {\n        fixX(c.x);\n      }\n      if (c.type & SVGPathData.VERT_LINE_TO) {\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.LINE_TO) {\n        fixX(c.x);\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.CURVE_TO) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        const xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);\n\n        for (const derivRoot of xDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));\n          }\n        }\n        const yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);\n\n        for (const derivRoot of yDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));\n          }\n        }\n      }\n      if (c.type & SVGPathData.ARC) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        annotateArcCommand(c, prevXAbs, prevYAbs);\n        // p = cos(phi) * xv + sin(phi) * yv\n        // dp = -sin(phi) * xv + cos(phi) * yv = 0\n        const xRotRad = c.xRot / 180 * Math.PI;\n        // points on ellipse for phi = 0° and phi = 90°\n        const x0 = Math.cos(xRotRad) * c.rX;\n        const y0 = Math.sin(xRotRad) * c.rX;\n        const x90 = -Math.sin(xRotRad) * c.rY;\n        const y90 = Math.cos(xRotRad) * c.rY;\n\n        // annotateArcCommand returns phi1 and phi2 such that -180° < phi1 < 180° and phi2 is smaller or greater\n        // depending on the sweep flag. Calculate phiMin, phiMax such that -180° < phiMin < 180° and phiMin < phiMax\n        const [phiMin, phiMax] = c.phi1 < c.phi2 ?\n          [c.phi1, c.phi2] :\n          (-180 > c.phi2 ? [c.phi2 + 360, c.phi1 + 360] : [c.phi2, c.phi1]);\n        const normalizeXiEta = ([xi, eta]: [number, number]) => {\n          const phiRad = Math.atan2(eta, xi);\n          const phi = phiRad * 180 / Math.PI;\n\n          return phi < phiMin ? phi + 360 : phi;\n        };\n        // xi = cos(phi), eta = sin(phi)\n\n        const xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);\n        for (const derivRoot of xDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixX(arcAt(c.cX, x0, x90, derivRoot));\n          }\n        }\n\n        const yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);\n        for (const derivRoot of yDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixY(arcAt(c.cY, y0, y90, derivRoot));\n          }\n        }\n      }\n      return command;\n    }) as any;\n\n    f.minX = Infinity;\n    f.maxX = -Infinity;\n    f.minY = Infinity;\n    f.maxY = -Infinity;\n    return f;\n  }\n}\n","import { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformFunction } from \"./types\";\n\nexport abstract class TransformableSVG {\n  round(x?: number) {\n    return this.transform(SVGPathDataTransformer.ROUND(x));\n  }\n\n  toAbs() {\n    return this.transform(SVGPathDataTransformer.TO_ABS());\n  }\n\n  toRel() {\n    return this.transform(SVGPathDataTransformer.TO_REL());\n  }\n\n  normalizeHVZ(a?: boolean, b?: boolean, c?: boolean) {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_HVZ(a, b, c));\n  }\n\n  normalizeST() {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_ST());\n  }\n\n  qtToC() {\n    return this.transform(SVGPathDataTransformer.QT_TO_C());\n  }\n\n  aToC() {\n    return this.transform(SVGPathDataTransformer.A_TO_C());\n  }\n\n  sanitize(eps?: number) {\n    return this.transform(SVGPathDataTransformer.SANITIZE(eps));\n  }\n\n  translate(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.TRANSLATE(x, y));\n  }\n\n  scale(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.SCALE(x, y));\n  }\n\n  rotate(a: number, x?: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.ROTATE(a, x, y));\n  }\n\n  matrix(a: number, b: number, c: number, d: number, e: number, f: number) {\n    return this.transform(SVGPathDataTransformer.MATRIX(a, b, c, d, e, f));\n  }\n\n  skewX(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_X(a));\n  }\n\n  skewY(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_Y(a));\n  }\n\n  xSymmetry(xOffset?: number) {\n    return this.transform(SVGPathDataTransformer.X_AXIS_SYMMETRY(xOffset));\n  }\n\n  ySymmetry(yOffset?: number) {\n    return this.transform(SVGPathDataTransformer.Y_AXIS_SYMMETRY(yOffset));\n  }\n\n  annotateArcs() {\n    return this.transform(SVGPathDataTransformer.ANNOTATE_ARCS());\n  }\n\n  abstract transform(transformFunction: TransformFunction): this;\n}\n","// Parse SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\nimport { COMMAND_ARG_COUNTS, SVGPathData } from \"./SVGPathData\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand, TransformFunction } from \"./types\";\n// Private consts : Char groups\nconst isWhiteSpace = (c: string) =>\n  \" \" === c || \"\\t\" === c || \"\\r\" === c || \"\\n\" === c;\nconst isDigit = (c: string) =>\n  \"0\".charCodeAt(0) <= c.charCodeAt(0) && c.charCodeAt(0) <= \"9\".charCodeAt(0);\nconst COMMANDS = \"mMzZlLhHvVcCsSqQtTaA\";\n\nexport class SVGPathDataParser extends TransformableSVG {\n  private curNumber: string = \"\";\n  private curCommandType: SVGCommand[\"type\"] | -1 = -1;\n  private curCommandRelative = false;\n  private canParseCommandOrComma = true;\n  private curNumberHasExp = false;\n  private curNumberHasExpDigits = false;\n  private curNumberHasDecimal = false;\n  private curArgs: number[] = [];\n\n  constructor() {\n    super();\n  }\n\n  finish(commands: SVGCommand[] = []) {\n    this.parse(\" \", commands);\n    // Adding residual command\n    if (0 !== this.curArgs.length || !this.canParseCommandOrComma) {\n      throw new SyntaxError(\"Unterminated command at the path end.\");\n    }\n    return commands;\n  }\n\n  parse(str: string, commands: SVGCommand[] = []) {\n    const finishCommand = (command: SVGCommand) => {\n      commands.push(command);\n      this.curArgs.length = 0;\n      this.canParseCommandOrComma = true;\n    };\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      // White spaces parsing\n      const isAArcFlag = this.curCommandType === SVGPathData.ARC &&\n        (this.curArgs.length === 3 || this.curArgs.length === 4) &&\n        this.curNumber.length === 1 &&\n        (this.curNumber === \"0\" || this.curNumber === \"1\");\n      const isEndingDigit = isDigit(c) && (\n        (this.curNumber === \"0\" && c === \"0\") ||\n        isAArcFlag\n      );\n\n      if (\n        isDigit(c) &&\n        !isEndingDigit\n      ) {\n        this.curNumber += c;\n        this.curNumberHasExpDigits = this.curNumberHasExp;\n        continue;\n      }\n      if (\"e\" === c || \"E\" === c) {\n        this.curNumber += c;\n        this.curNumberHasExp = true;\n        continue;\n      }\n      if (\n        (\"-\" === c || \"+\" === c) &&\n        this.curNumberHasExp &&\n        !this.curNumberHasExpDigits\n      ) {\n        this.curNumber += c;\n        continue;\n      }\n      // if we already have a \".\", it means we are starting a new number\n      if (\".\" === c && !this.curNumberHasExp && !this.curNumberHasDecimal && !isAArcFlag) {\n        this.curNumber += c;\n        this.curNumberHasDecimal = true;\n        continue;\n      }\n\n      // New number\n      if (this.curNumber && -1 !== this.curCommandType) {\n        const val = Number(this.curNumber);\n        if (isNaN(val)) {\n          throw new SyntaxError(`Invalid number ending at ${i}`);\n        }\n        if (this.curCommandType === SVGPathData.ARC) {\n          if (0 === this.curArgs.length || 1 === this.curArgs.length) {\n            if (0 > val) {\n              throw new SyntaxError(\n                `Expected positive number, got \"${val}\" at index \"${i}\"`,\n              );\n            }\n          } else if (3 === this.curArgs.length || 4 === this.curArgs.length) {\n            if (\"0\" !== this.curNumber && \"1\" !== this.curNumber) {\n              throw new SyntaxError(\n                `Expected a flag, got \"${this.curNumber}\" at index \"${i}\"`,\n              );\n            }\n          }\n        }\n        this.curArgs.push(val);\n        if (this.curArgs.length === COMMAND_ARG_COUNTS[this.curCommandType]) {\n          if (SVGPathData.HORIZ_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.HORIZ_LINE_TO,\n              relative: this.curCommandRelative,\n              x: val,\n            });\n          } else if (SVGPathData.VERT_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.VERT_LINE_TO,\n              relative: this.curCommandRelative,\n              y: val,\n            });\n            // Move to / line to / smooth quadratic curve to commands (x, y)\n          } else if (\n            this.curCommandType === SVGPathData.MOVE_TO ||\n            this.curCommandType === SVGPathData.LINE_TO ||\n            this.curCommandType === SVGPathData.SMOOTH_QUAD_TO\n          ) {\n            finishCommand({\n              type: this.curCommandType,\n              relative: this.curCommandRelative,\n              x: this.curArgs[0],\n              y: this.curArgs[1],\n            } as SVGCommand);\n            // Switch to line to state\n            if (SVGPathData.MOVE_TO === this.curCommandType) {\n              this.curCommandType = SVGPathData.LINE_TO;\n            }\n          } else if (this.curCommandType === SVGPathData.CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.CURVE_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x2: this.curArgs[2],\n              y2: this.curArgs[3],\n              x: this.curArgs[4],\n              y: this.curArgs[5],\n            });\n          } else if (this.curCommandType === SVGPathData.SMOOTH_CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.SMOOTH_CURVE_TO,\n              relative: this.curCommandRelative,\n              x2: this.curArgs[0],\n              y2: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.QUAD_TO) {\n            finishCommand({\n              type: SVGPathData.QUAD_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.ARC) {\n            finishCommand({\n              type: SVGPathData.ARC,\n              relative: this.curCommandRelative,\n              rX: this.curArgs[0],\n              rY: this.curArgs[1],\n              xRot: this.curArgs[2],\n              lArcFlag: this.curArgs[3] as 0 | 1,\n              sweepFlag: this.curArgs[4] as 0 | 1,\n              x: this.curArgs[5],\n              y: this.curArgs[6],\n            });\n          }\n        }\n        this.curNumber = \"\";\n        this.curNumberHasExpDigits = false;\n        this.curNumberHasExp = false;\n        this.curNumberHasDecimal = false;\n        this.canParseCommandOrComma = true;\n      }\n      // Continue if a white space or a comma was detected\n      if (isWhiteSpace(c)) {\n        continue;\n      }\n      if (\",\" === c && this.canParseCommandOrComma) {\n        // L 0,0, H is not valid:\n        this.canParseCommandOrComma = false;\n        continue;\n      }\n      // if a sign is detected, then parse the new number\n      if (\"+\" === c || \"-\" === c || \".\" === c) {\n        this.curNumber = c;\n        this.curNumberHasDecimal = \".\" === c;\n        continue;\n      }\n      // if a 0 is detected, then parse the new number\n      if (isEndingDigit) {\n        this.curNumber = c;\n        this.curNumberHasDecimal = false;\n        continue;\n      }\n\n      // Adding residual command\n      if (0 !== this.curArgs.length) {\n        throw new SyntaxError(`Unterminated command at index ${i}.`);\n      }\n      if (!this.canParseCommandOrComma) {\n        throw new SyntaxError(\n          `Unexpected character \"${c}\" at index ${i}. Command cannot follow comma`,\n        );\n      }\n      this.canParseCommandOrComma = false;\n      // Detecting the next command\n      if (\"z\" === c || \"Z\" === c) {\n        commands.push({\n          type: SVGPathData.CLOSE_PATH,\n        });\n        this.canParseCommandOrComma = true;\n        this.curCommandType = -1;\n        continue;\n        // Horizontal move to command\n      } else if (\"h\" === c || \"H\" === c) {\n        this.curCommandType = SVGPathData.HORIZ_LINE_TO;\n        this.curCommandRelative = \"h\" === c;\n        // Vertical move to command\n      } else if (\"v\" === c || \"V\" === c) {\n        this.curCommandType = SVGPathData.VERT_LINE_TO;\n        this.curCommandRelative = \"v\" === c;\n        // Move to command\n      } else if (\"m\" === c || \"M\" === c) {\n        this.curCommandType = SVGPathData.MOVE_TO;\n        this.curCommandRelative = \"m\" === c;\n        // Line to command\n      } else if (\"l\" === c || \"L\" === c) {\n        this.curCommandType = SVGPathData.LINE_TO;\n        this.curCommandRelative = \"l\" === c;\n        // Curve to command\n      } else if (\"c\" === c || \"C\" === c) {\n        this.curCommandType = SVGPathData.CURVE_TO;\n        this.curCommandRelative = \"c\" === c;\n        // Smooth curve to command\n      } else if (\"s\" === c || \"S\" === c) {\n        this.curCommandType = SVGPathData.SMOOTH_CURVE_TO;\n        this.curCommandRelative = \"s\" === c;\n        // Quadratic bezier curve to command\n      } else if (\"q\" === c || \"Q\" === c) {\n        this.curCommandType = SVGPathData.QUAD_TO;\n        this.curCommandRelative = \"q\" === c;\n        // Smooth quadratic bezier curve to command\n      } else if (\"t\" === c || \"T\" === c) {\n        this.curCommandType = SVGPathData.SMOOTH_QUAD_TO;\n        this.curCommandRelative = \"t\" === c;\n        // Elliptic arc command\n      } else if (\"a\" === c || \"A\" === c) {\n        this.curCommandType = SVGPathData.ARC;\n        this.curCommandRelative = \"a\" === c;\n      } else {\n        throw new SyntaxError(`Unexpected character \"${c}\" at index ${i}.`);\n      }\n    }\n    return commands;\n  }\n  /**\n   * Return a wrapper around this parser which applies the transformation on parsed commands.\n   */\n  transform(transform: TransformFunction) {\n    const result = Object.create(this, {\n      parse: {\n        value(chunk: string, commands: SVGCommand[] = []) {\n          const parsedCommands = Object.getPrototypeOf(this).parse.call(\n            this,\n            chunk,\n          );\n          for (const c of parsedCommands) {\n            const cT = transform(c);\n            if (Array.isArray(cT)) {\n              commands.push(...cT);\n            } else {\n              commands.push(cT);\n            }\n          }\n          return commands;\n        },\n      },\n    });\n    return result as this;\n  }\n}\n","import { encodeSVGPath } from \"./SVGPathDataEncoder\";\nimport { SVGPathDataParser } from \"./SVGPathDataParser\";\nimport { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand } from \"./types\";\n\nexport class SVGPathData extends TransformableSVG {\n  commands: SVGCommand[];\n  constructor(content: string | SVGCommand[]) {\n    super();\n    if (\"string\" === typeof content) {\n      this.commands = SVGPathData.parse(content);\n    } else {\n      this.commands = content;\n    }\n  }\n\n  encode() {\n    return SVGPathData.encode(this.commands);\n  }\n\n  getBounds() {\n    const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();\n\n    this.transform(boundsTransform);\n    return boundsTransform;\n  }\n\n  transform(\n    transformFunction: (input: SVGCommand) => SVGCommand | SVGCommand[],\n  ) {\n    const newCommands = [];\n\n    for (const command of this.commands) {\n      const transformedCommand = transformFunction(command);\n\n      if (Array.isArray(transformedCommand)) {\n        newCommands.push(...transformedCommand);\n      } else {\n        newCommands.push(transformedCommand);\n      }\n    }\n    this.commands = newCommands;\n    return this;\n  }\n\n  static encode(commands: SVGCommand[]) {\n    return encodeSVGPath(commands);\n      }\n\n  static parse(path: string) {\n    const parser = new SVGPathDataParser();\n    const commands: SVGCommand[] = [];\n    parser.parse(path, commands);\n    parser.finish(commands);\n    return commands;\n  }\n\n  static readonly CLOSE_PATH: 1 = 1;\n  static readonly MOVE_TO: 2 = 2;\n  static readonly HORIZ_LINE_TO: 4 = 4;\n  static readonly VERT_LINE_TO: 8 = 8;\n  static readonly LINE_TO: 16 = 16;\n  static readonly CURVE_TO: 32 = 32;\n  static readonly SMOOTH_CURVE_TO: 64 = 64;\n  static readonly QUAD_TO: 128 = 128;\n  static readonly SMOOTH_QUAD_TO: 256 = 256;\n  static readonly ARC: 512 = 512;\n  static readonly LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;\n  static readonly DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO | SVGPathData.LINE_TO |\n  SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO | SVGPathData.QUAD_TO |\n  SVGPathData.SMOOTH_QUAD_TO | SVGPathData.ARC;\n}\n\nexport const COMMAND_ARG_COUNTS = {\n    [SVGPathData.MOVE_TO]: 2,\n    [SVGPathData.LINE_TO]: 2,\n    [SVGPathData.HORIZ_LINE_TO]: 1,\n    [SVGPathData.VERT_LINE_TO]: 1,\n    [SVGPathData.CLOSE_PATH]: 0,\n    [SVGPathData.QUAD_TO]: 4,\n    [SVGPathData.SMOOTH_QUAD_TO]: 2,\n    [SVGPathData.CURVE_TO]: 6,\n    [SVGPathData.SMOOTH_CURVE_TO]: 4,\n    [SVGPathData.ARC]: 7,\n};\n\nexport {encodeSVGPath} from \"./SVGPathDataEncoder\";\nexport {SVGPathDataParser} from \"./SVGPathDataParser\";\nexport {SVGPathDataTransformer} from \"./SVGPathDataTransformer\";\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}